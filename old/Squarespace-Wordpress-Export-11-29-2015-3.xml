<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:wp="http://wordpress.org/export/1.2/">
  <channel>
    <title>sawanoboly.net</title>
    <link>http://www.sawanoboly.net</link>
    <pubDate>Sun, 05 Jan 2014 16:31:54 +0000</pubDate>
    <description>be disposable.</description>
    <language>ja-JP</language>
    <wp:wxr_version>1.2</wp:wxr_version>
    <wp:author>
      <wp:author_id>1016713160</wp:author_id>
      <wp:author_login>sawanoboriyu@higanworks.com</wp:author_login>
      <wp:author_email>sawanoboriyu@higanworks.com</wp:author_email>
      <wp:author_display_name><![CDATA[Sawanobori Yukihiko]]></wp:author_display_name>
      <wp:author_first_name><![CDATA[Yukihiko]]></wp:author_first_name>
      <wp:author_last_name><![CDATA[Sawanobori]]></wp:author_last_name>
    </wp:author>
    <wp:category>
      <wp:cat_name><![CDATA[null - null]]></wp:cat_name>
      <wp:category_nicename>null-null</wp:category_nicename>
      <wp:category_parent />
    </wp:category>
    <item>
      <title>日本語訳: CircuitBreaker</title>
      <link>/contribution/2014/3/17/circuitbreaker</link>
      <content:encoded><![CDATA[<p>日本語訳: CircuitBreaker</p>

<p><a href="https://github.com/azukiwasher/">@azukiwasher</a> さんから[ThoughtWorks][1]のMartin Fowler氏がブログで公開した記事の日本語訳を頂きました。</p>

<blockquote>
  <p>「サーバインスタンスとか証明書とかドメインとかゾーンとか、あっちこっちの外部 API をつなげてあげるユニットって結構いままでにつくってるよなぁ」という感慨とともに、そんなユニットに必須のテクニックをファウラー御大が丁寧に解説されていたので訳してみました</p>
</blockquote>

<p>なるほど、最近触ってるあれでは、sidekiq proに使ってこういったカラクリに近いことをやってもらっている感じです。</p>

<hr />

<h1 id="">サーキット・ブレーカー</h1>

<p>ソース: <br />
"CircuitBreaker" <br />
<a href="http://martinfowler.com/bliki/CircuitBreaker.html">http://martinfowler.com/bliki/CircuitBreaker.html</a> by Martin Fowler</p>

<p>ソフトウェア・システムでは、まったくの別プロセスやネットワーク越しの別マシンで実行されているソフトウェアに対してリモート・コールすることがよく起こります。 <br />
インメモリへのコールとリモート・コールとの大きな違いは、リモート・コールはフェイルしたり、レスポンスのないまま一定時間ハングしてしまうケースがあることです。
レスポンスを返さないサプライヤへ大量にコールしたせいで、重篤なリソース不足を招き、システム間でフェイルの連鎖を誘発させてしまうと最悪です。 <br />
Michael Nygard 氏は "<a href="http://www.amazon.com/gp/product/0978739213">Release It</a>" という卓越した著書のなかで、こうした致命的なフェイルの連鎖を防ぐために「サーキット・ブレーカー」というパターンを推奨しています。</p>

<p>サーキット・ブレーカーという発想のベースにあるアイデアはとてもシンプルです。
プロテクテッドなコール関数をサーキット・ブレーカー・オブジェクトにラップし、そのオブジェクトがコールの結果をモニタリングするのです。
フェイルした回数が閾値に達したら、サーキット・ブレーカーはトリップしてそれ以降のコールをエラーとして返します。 <br />
リモートへのプロテクテッドなコールは一切発生しません。通常であれば、サーキット・ブレーカーのトリップが発生したらアラートが欲しいところでしょう。</p>

<p><img src="http://martinfowler.com/bliki/images/circuitBreaker/sketch.png" alt="" title="" /></p>

<p>以下は、サーキット・ブレーカーのビヘイビアを Ruby で実装したサンプルです。タイムアウトしたらプロテクトします。</p>

<p>ブロック（<a href="http://martinfowler.com/bliki/Lambda.html">Lambda</a>）を引数にして、ブレーカーをセットアップします。このブロックがプロテクテッドなコールに相当します。</p>

<pre data-preserve-html-node="true"><code data-preserve-html-node="true">cb = CircuitBreaker.new {|arg| @supplier.func arg}
</code></pre>

<p>ブレーカーはブロックを保存して、いろいろなパラメータ（閾値、タイムアウト、モニタリング）を初期化します。そして「クローズド」な状態に設定します。</p>

<pre data-preserve-html-node="true"><code data-preserve-html-node="true">class CircuitBreaker...
  attr_accessor :invocation_timeout, :failure_threshold, :monitor

  def initialize &block
    @circuit = block
    @invocation_timeout = 0.01
    @failure_threshold = 5
    @monitor = acquire_monitor
    reset
  end
</code></pre>

<p>サーキット・ブレーカーにコールがあると、状態がクローズドならブロックが呼ばれ、オープンならエラーになります。</p>

<pre data-preserve-html-node="true"><code data-preserve-html-node="true"># client code
aCircuitBreaker.call(5)
</code></pre>

<pre data-preserve-html-node="true"><code data-preserve-html-node="true">class CircuitBreaker...
  def call args
    case state
    when :closed
    begin
      do_call args
    rescue Timeout::Error
      record_failure
      raise $!
    end
    when :open then
      raise CircuitBreaker::Open
    else
      raise "Unreachable Code"
    end
  end

  def do_call args
    result = Timeout::timeout(@invocation_timeout) do
      @circuit.call args
    end
    reset
    return result
  end
</code></pre>

<p>タイムアウトが発生した、フェイルカウントをインクリメントしてきます。コールに成功したらフェイルカウントをゼロにリセットします。</p>

<pre data-preserve-html-node="true"><code data-preserve-html-node="true">class CircuitBreaker...
  def record_failure
    @failure_count += 1
    @monitor.alert(:open_circuit) if :open == state
  end

  def reset
    @failure_count = 0
    @monitor.alert :reset_circuit
  end
</code></pre>

<p>ブレーカの状態はフェイルカウントと閾値を比較して決定します。</p>

<pre data-preserve-html-node="true"><code data-preserve-html-node="true">class CircuitBreaker...
  def state
    (@failure_count >= @failure_threshold) ? :open : :closed
  end
</code></pre>

<p>このようなシンプルなサーキット・ブレーカーの実装では、サーキットがオープンならプロテクテッドなコールを遮断しますが、復旧時の状態リセットには外部からの別操作が必要になるかもしれません。 <br />
物理的なビルの電気的なサーキット・ブレーカー（遮断機）であればそうした操作ももっともでしょうが、ソフトウェアに関して言えばブレーカー自身に復旧を検知させることができます。
妥当な間隔をおいて、プロテクテッドなコールを再実行し、成功であればブレーカーをリセットするような自己回復的なビヘイビアを実装することができます。</p>

<p><img src="http://martinfowler.com/bliki/images/circuitBreaker/state.png" alt="" title="" /></p>

<p>自己回復的なブレーカーに必要なのは、リセットを試行するための閾値の追加と、直近のエラーが発生した時刻を保持する変数への代入です。</p>

<pre data-preserve-html-node="true"><code data-preserve-html-node="true">class ResetCircuitBreaker...
  def initialize &block
    @circuit = block
    @invocation_timeout = 0.01
    @failure_threshold = 5
    @monitor = BreakerMonitor.new
    @reset_timeout = 0.1
    reset
  end

  def reset
    @failure_count = 0
    @last_failure_time = nil
    @monitor.alert :reset_circuit
  end
</code></pre>

<p>ここで３つめの状態ーハーフ・オープンーが現れます。
ハーフ・オープンな状態のとき、サーキットは実際のコールを、問題が落ち着いたかチェックする試行として受け付けます。</p>

<pre data-preserve-html-node="true"><code data-preserve-html-node="true">class ResetCircuitBreaker...
  def state
    case
    when (@failure_count >= @failure_threshold) 
      && (Time.now - @last_failure_time) > @reset_timeout 
      :half_open
    when (@failure_count >= @failure_threshold)
      :open
    else
      :closed
    end
  end
</code></pre>

<p>ハーフ・オープン状態のときのコールは、そのコールが成功したらブレーカーをリセットする、失敗ならタイムアウトを巻き戻す、そのいずれかを試行します。</p>

<pre data-preserve-html-node="true"><code data-preserve-html-node="true">class ResetCircuitBreaker...
  def call args
    case state
    when :closed, :half_open
      begin
        do_call args
      rescue Timeout::Error
        record_failure
        raise $!
      end
    when :open
      raise CircuitBreaker::Open
    else
      raise "Unreachable"
    end
  end

  def record_failure
    @failure_count += 1
    @monitor.alert(:open_circuit) if :open == state
    @last_failure_time = Time.now
  end
</code></pre>

<p>上に紹介した例は、あくまで説明向けの素朴な実装です。
実際のサーキット・ブレーカーにはもっとたくさんのフィーチャが実装され、パラメータ化が施されるはずです。 <br />
プロテクテッドなコールがライズするエラーの種別、例えばネットワーク接続エラーなど、どこまでのエラーをプロテクトすべきか考慮することでしょう。
すべてのエラーに対してサーキットをトリップすべきではありません。
中には想定内のエラーも含まれるますので、そういったエラーは通常のロジックで処理したほうが無難です。</p>

<p>トラフィックが増えてくると、初期の閾値でタイムアウトしてしまうコールの増加に悩まされるかもしれません。
リモート・コールはよく遅くなるので、コールごとにスレッドを分けて実行するというアイデアは使えるでしょう。 <br />
その際、"<a href="http://en.wikipedia.org/wiki/Futures_and_promises">future or promise</a>" を利用して各スレッドの戻りの結果をハンドルしてやります。
スレッドプールからスレッドを取り出していくと、いつかスレッドプールが枯渇します。
そのときにサーキットを遮断するというアレンジができます。</p>

<p>例では、ブレーカーをトリップさせるシンプルな方法を紹介しました。
コールが成功ならカウントをリセットします。
もうすこし洗練されたアプローチでは、トリップが一度発生すると失敗率 50% といったように、エラー発生頻度をベースにできるかもしれません。 <br />
また、エラーごとに異なる閾値をもたせるといったアプローチもあるでしょう。
例えば、タイムアウトであれば閾値 10、接続障害なら閾値 3 といった具合です。 </p>

<p>例では、サーキット・ブレーカーを同期的に呼び出していますが、非同期なやりとりでもサーキット・ブレーカーは使えます。 <br />
非同期の一般的なテクニックでは、すべてのリクエストをキューに入れます。
サプライヤーは自分のペースでリクエストをコンシュームするので、サーバのオーバーロードを防ぐ有効なテクニックのひとつです。</p>

<p>サーキット・ブレーカーは、フェイルしそうなオペレーションに割かれるリソースを削減してくれます。
タイムアウトするまでクライアントを待たせずに済みますし、サーキットを遮断することで処理に四苦八苦しているサーバへの負荷をカットできます。 <br />
ここまではサーキット・ブレーカーの使いどころとして、一般的に知られるリモート・コールに絞ってお話ししてきましたが、システムのある部分を他の部分で発生した問題からプロテクトするシチュエーションであれば、大概はサーキット・ブレーカーが使えます。</p>

<p>サーキット・ブレーカーは、モニタリングのための貴重な場所になります。
ブレーカーの状態遷移をすべてログに残し、詳細な出力結果からより深いモニタリングにつなげます。
ブレーカーのビヘイビアは、より深刻な環境上のトラブルの兆候を知るための有益な情報源です。
オペレーション・スタッフはサーキットのトリップかブレーカーのリセットはできたほうがよいでしょう。</p>

<p>ブレーカーはそれ自体でも価値があるのですが、リクエスト・エラーに対してクライアントはどう対応すべきか、その判断にもおいても貴重です。
実行中のオペレーションが失敗したら、何らかのワークアラウンドが可能なのか考えてみてください。 <br />
クレジットカード認証のリクエストは、いったんキューに入れて時間をおいて処理できるかもしれませんし、あるデータが取得できなかったときは、前回取得したデータを表示することで失敗を緩和できるかもしれません。</p>

<h3 id="">さらに知りたい人のために</h3>

<p>Netflix の技術ブログには、多くの外部サービスと連携するシステムの信頼性を高めるための方策について、有益な情報が数多く掲載されています。
なかでも、"<a href="http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html">Fault Tolerance in a High Volume, Distributed System</a>" というポストで、サーキット・ブレーカーとスレッド・プール・リミットに触れられています。</p>

<p>Netflix は <a href="https://github.com/Netflix/Hystrix/">Hystrix</a> という分散環境のためのレイテンシとフォールトトレラントを制御する洗練されたツールをオープンソースで公開しています。
そこには、スレッド・プール・リミットによるサーキット・ブレーカー・パターンの実装が含まれています。</p>

<p>他にも、<a href="https://github.com/wsargent/circuit_breaker/tree/master">Ruby</a>, <a href="https://github.com/Comcast/jrugged">Java</a>, <a href="http://www.grails.org/plugin/circuit-breaker">Grails Plugin</a>, <a href="http://timross.wordpress.com/2008/02/10/implementing-the-circuit-breaker-pattern-in-c/">C#</a>, <a href="https://github.com/sptz45/circuit-breaker/tree/master">AspectJ</a>, <a href="https://github.com/FaKod/Circuit-Breaker-for-Scala">Scala</a> によるオープンソースなサーキット・ブレーカー・パターンの実装があります。</p>]]></content:encoded>
      <excerpt:encoded />
      <wp:post_name>2014/3/17/circuitbreaker</wp:post_name>
      <wp:post_type>post</wp:post_type>
      <wp:post_id>0</wp:post_id>
      <wp:status>publish</wp:status>
      <pubDate>Mon, 17 Mar 2014 08:59:15 +0000</pubDate>
      <wp:post_date>2014-03-17 08:59:15</wp:post_date>
      <wp:post_date_gmt>2014-03-17 08:59:15</wp:post_date_gmt>
      <category domain="post_tag" nicename="translate"><![CDATA[translate]]></category>
      <category domain="post_tag" nicename="delivery"><![CDATA[delivery]]></category>
      <category domain="post_tag" nicename="application-architecture"><![CDATA[application architecture]]></category>
      <dc:creator>sawanoboriyu@higanworks.com</dc:creator>
      <wp:comment_status>open</wp:comment_status>
    </item>
    <item>
      <title>日本語訳: Ruby 2.1: Out-of-Band GC</title>
      <link>/contribution/2014/3/13/ruby-21-out-of-band-gc</link>
      <content:encoded><![CDATA[<p><a href="https://github.com/azukiwasher/">@azukiwasher</a> さんからRuby2.1のGCについて解説されている記事の日本語訳を頂きました。</p>

<p>『WEB+DB の Ruby 2.1 特集を読んでたら、ガベージコレクション（RGenGC）の説明で参照されてた記事の次の記事がためになったので訳してみた。』</p>

<p><a href="http://gihyo.jp/magazine/wdpress/archive/2014/vol79">Vol.79</a>ですね。</p>

<hr />

<p>ソース
<a href="http://tmm1.net/ruby21-oobgc/" title="Ruby 2.1: Out-of-Band GC · computer talk by @tmm1">Ruby 2.1: Out-of-Band GC · computer talk by @tmm1</a></p>

<h1 id="ruby21outofbandgc">Ruby 2.1: Out-of-Band GC</h1>

<p>Ruby 2.1 で <a href="http://tmm1.net/ruby21-rgengc/">GC は以前よりずっとマシ</a>になったが、相変わらず "Stop The World" な実装に変わりはない。リクエスト処理中にコレクションが始まると、リクエストへの応答時間に遅延が生じる。遅延を緩和する方法のひとつにリクエストとリクエストの間に GC を走らせる、いわゆる「Out-of-Band」がある。</p>

<p>OOBGC はよく知られたテクニックで、<a href="http://unicorn.bogomips.org/Unicorn/OobGC.html">Unicorn</a> で最初に導入され、しばらくして <a href="http://blog.phusion.nl/2013/01/22/phusion-passenger-4-technology-preview-out-of-band-work/">Passenger</a> でも実装された。これらは、リクエスト n 回ごとに強制的に GC を実行するという伝統的なやりかたを採用しているのだが、これをうまく動かすにはチューニングに気を使うし、不要なコレクションが頻繁に起こると CPU にプレッシャをかけてしまう。</p>

<p><a href="https://blog.twitter.com/2011/faster-ruby-kiji-update">kiji（twitter による REE フォーク）</a> では、@evanweaver が <a href="https://github.com/twitter-forks/rubyenterpriseedition187-248/commit/951ca6a73e#commitcomment-476298">GC.preemptive_start</a> を導入し「リクエスト n 回ごと」に対する別解を与えた。この新しい手法はヒープサイズとフリースロット数をベースにして OOBGC の実行タイミングを決定するという、より賢明なやりかただった。われわれもしばらくの間、同じトリックを 1.9.3 のフォークに実装して github.com の OOBGC を最適化していた。</p>

<p>今月（２月）はじめ、<a href="https://gist.github.com/tmm1/8393897">パッチを当てた 2.1.0</a> にプロダクション環境をアップグレードした際、このテクニックを <a href="https://github.com/tmm1/gctools">RGenGC 向けの新たな OOBGC</a> として焼き直した。GC をフックする Ruby 2.1 の新しいトレースポイントのパワーのおかげで、コレクションが必要になったときのベストなアプローチが、Lazy sweep なのか Immediate sweep なのか、メジャー GC なのか マイナー GC なのか、そうした選択が可能なよう考慮されている。</p>

<p>新しい OOBGC の使い方はシンプルだ：</p>

<pre data-preserve-html-node="true"><code data-preserve-html-node="true">require 'gctools/oobgc'
GC::OOB.run() # リクエスト Body がフラッシュされるごとに実行
</code></pre>

<p>Unicorn を使っている場合：</p>

<pre data-preserve-html-node="true"><code data-preserve-html-node="true"># config.ru
require 'gctools/oobgc'
if defined?(Unicorn::HttpRequest)
  use GC::OOB::UnicornMiddleware
end
</code></pre>

<h2 id="oobgc">OOBGC 計測結果</h2>

<p><img src="http://cl.ly/image/3q1L2h3w1A1s/graph.png" alt="" title="" /></p>

<p>Ruby 2.1 での OOBGC の停止時間（oobgc.mean）の平均は、<a href="http://tmm1.net/ruby21-rgengc/">RGenGC</a> のおかげで 125ms から 50ms に減少した。また、OOBG コレクションの実行回数（oobgc.count）も減った。これは新しい OOBGC が本当に必要な時しか実行されなくなったからだ。</p>

<p><img src="http://cl.ly/image/3c0N1I0p0n2W/graph.png" alt="http://cl.ly/image/3c0N1I0p0n2W/graph.png" title="" /></p>

<p>リクエストとリクエストの狭間に GC を実行する CPU 時間（oobgc.sum）も全体として減少している。</p>

<h2 id="gc">GC 実行回数</h2>

<p><img src="http://cl.ly/image/0G2P2l0N1z0J/graph.png" alt="http://cl.ly/image/0G2P2l0N1z0J/graph.png" title="" /></p>

<p>2.1 へアップグレードしてから、リクエスト中の GC 実行回数が 2〜3 倍増加している（gc.time.count）。メジャー GC はプリエンプティブに実行されるため、リクエスト中に発生しているのはマイナー GC だけで、停止時間の平均もわずか 25 ms だ（gc.time.mean）。</p>

<p><img src="http://cl.ly/image/0g463K3q0O05/graph.png" alt="http://cl.ly/image/0g463K3q0O05/graph.png" title="" /></p>

<p>以前よりも GC 自体は頻繁に発生しているものの、リクエスト中の GC によるオーバーヘッド（gc.time.sum）は全体として削減されている。</p>

<p>注：最高の OOBGC でも、リクエスト中のコレクション発生は避けられない（特に、メモリーをたくさん使うような大きなリクエストのとき）。リクエスト中の GC はメモリ使用量増加をコントロールしてくれるので、リクエスト中の Ruby の GC を無効にするのは、<em>個人的にはオススメできない</em>。</p>]]></content:encoded>
      <excerpt:encoded />
      <wp:post_name>2014/3/13/ruby-21-out-of-band-gc</wp:post_name>
      <wp:post_type>post</wp:post_type>
      <wp:post_id>1</wp:post_id>
      <wp:status>publish</wp:status>
      <pubDate>Thu, 13 Mar 2014 12:06:28 +0000</pubDate>
      <wp:post_date>2014-03-13 12:06:28</wp:post_date>
      <wp:post_date_gmt>2014-03-13 12:06:28</wp:post_date_gmt>
      <category domain="post_tag" nicename="translate"><![CDATA[translate]]></category>
      <category domain="post_tag" nicename="ruby"><![CDATA[ruby]]></category>
      <dc:creator>sawanoboriyu@higanworks.com</dc:creator>
      <wp:comment_status>open</wp:comment_status>
      <wp:comment>
        <wp:comment_id>1</wp:comment_id>
        <wp:comment_approved>1</wp:comment_approved>
        <wp:comment_author_email>aosho235@gmail.com</wp:comment_author_email>
        <wp:comment_author><![CDATA[Aoyama, Shotaro]]></wp:comment_author>
        <wp:comment_author_url />
        <wp:comment_author_IP>122.133.118.65</wp:comment_author_IP>
        <wp:comment_date>2015-08-08 05:14:32</wp:comment_date>
        <wp:comment_date_gmt>2015-08-08 05:14:32</wp:comment_date_gmt>
        <wp:comment_content><![CDATA[<p>すいません、このGC計測グラフは何と言うツールで作ったものか教えていただけないでしょうか？</p>]]></wp:comment_content>
        <wp:comment_type />
        <wp:comment_parent>0</wp:comment_parent>
      </wp:comment>
    </item>
    <item>
      <title>日本語訳：DevOps for developers w/Chef [Part III] (Guest Blog Series)</title>
      <link>/contribution/2014/3/13/devops-for-developers-wchef-part-iii-guest-blog-series</link>
      <content:encoded><![CDATA[<p><a href="https://github.com/azukiwasher/">@azukiwasher</a> さんからgetchef.comに寄稿されている記事の日本語訳を頂きました。 社内教育に活用するそうです。</p>

<p>元の記事はこちらです。 <a href="http://www.getchef.com/blog/2014/03/11/devops-for-developers-wchef-part-iii-guest-blog-series/">DevOps for developers w/Chef [Part III] (Guest Blog Series)</a></p>

<hr />

<p><strong>Lucas Welch</strong></p>

<p>引き続き、効率的なソフトウェア開発とデリバリの可能性を示唆する Michael Hüttermann 氏のゲストブログシリーズからご紹介します。３回目の今日は「DevOps マトリクス」です。</p>

<h2 id="devops">DevOps マトリクス</h2>

<p>DevOps はアジャイル、リーン、制約条件理論、カンバン方式、ITIL のような健全な実践、そして単なる良識など複数のコンセプトから成り立っています。DevOps は「何」をするべきかではなく「どのように」するかに関心があります。</p>

<p>みなさんもそろそろ、DevOps を分類して見取り図を広げてみたいと思っているかもしれません。DevOps マトリクスは DevOps を４つのエリアに区分することで DevOps の理解を助けます。</p>

<p>図 は DevOps エリア・マトリクスなアプローチを表現しています。これは Patrick Debois 氏のアプローチをベースにそれを発展させたものです。</p>

<p>エリア 1 は、デベロップメントのオペレーションへの拡張です。タスクを組織化し、その結果を追跡するためにカンバン方式を採用するのと共通のユースケースです
。ここでは、Chef のクックブック（ソースコード）をヴァージョン管理システムで管理し（Infrastructure as Code）、デベロップメントとオペレーションで同じプロビジョニング・ツールを利用します。</p>

<p>エリア 2 は、オペレーションのデベロップメントへの拡張です。システムのトラフィックやランタイムの挙動などの有益な情報を可視化して、デベロップメントが継続的にアクセスできるようにします。</p>

<p>エリア 3 は、デベロップメントのオペレーションへの組み込みです。非機能的な要件に対する制約と共通のゴールを明確にします。それは SLA の一部に含まれるものかもしれません。共通のゴールとしては、例えば、サービスが結果を画面に返すまでの時間が２秒未満である（パフォーマンス上の共通ゴール）、Linux ディストリビューションの変更が困難になるような技術は採用しない（可搬性の共通ゴール）、データベースがパフォーマンス目標を達成しながら特定のハードウェア上で 2,000 万メンバーの情報をストアできる（キャパシティ上の共通ゴール）、インフラストラクチャ・コードも含め、すべてのコンポーネントに対して自動化されたテストが必ず存在する（メンテナンス性の共通ゴール）などです。</p>

<p>エリア 4 は、オペレーションのデベロップメントへの組み込みです。デベロップメントがアドミニストレータたちの特段の介入なく、必要な情報にアクセスできるようにすることでコラボレーションを活性化する目的があります。また、運用環境を管理するシステムエキスパートたちをゲートキーパーにしてしまう過ちを防止できます。</p><p><img src="http://www.getchef.com/blog/wp-content/uploads/2014/03/Figure2_DevOps_Matrix.jpg" alt="Figure2<em>DevOps</em>Matrix" title="" /></p><p>ナレッジの循環と迅速なフィードバックを促すには、それぞれのエリアでの双方向（デベロップメントからオペレーション、あるいはその逆）のやり取りを強化していきます。実際の現場ではエリアどうしはオーバーラップします。</p>

<p>エリアを区別すると、DevOps を組織とプロジェクトに導入しやすくなりますし、相互理解の助けにもなります。４つのエリアは３つの基本的な視点、メトリクスと計測の視点、プロセスの視点、技術の視点をカバーしています。DevOps エリア・マトリクスというアプローチは、デベロップメントとオペレーションが、自分たちしかしらない内部プロセスや局所的に最適化されたソリューションにしがみついているという、よく見かけられる事実に端を発しています。</p>

<p>デベロップメントは「プロジェクト」の一部として組織され、そのゴールは限られたマンパワーで（決められたマイルストーンに基づく）所定の時間内に、一定の品質であらかじめ定義されたコンテンツ（スコープ）をデリバーすることです。プロジェクトとオペレーション・チームの活動は互いに連携すべきです。</p>

<p>ビジネス上の目標は、顧客満足や市場イメージの達成のように、共通のまじめなゴールとして機能します。しかし、まちがった解釈で DevOps を運用していることがままあります。次回は、そのあたりについてお話ししたいと思います。</p>]]></content:encoded>
      <excerpt:encoded />
      <wp:post_name>2014/3/13/devops-for-developers-wchef-part-iii-guest-blog-series</wp:post_name>
      <wp:post_type>post</wp:post_type>
      <wp:post_id>2</wp:post_id>
      <wp:status>publish</wp:status>
      <pubDate>Thu, 13 Mar 2014 04:15:32 +0000</pubDate>
      <wp:post_date>2014-03-13 04:15:32</wp:post_date>
      <wp:post_date_gmt>2014-03-13 04:15:32</wp:post_date_gmt>
      <category domain="post_tag" nicename="devops"><![CDATA[devops]]></category>
      <category domain="post_tag" nicename="translate"><![CDATA[translate]]></category>
      <dc:creator>sawanoboriyu@higanworks.com</dc:creator>
      <wp:comment_status>open</wp:comment_status>
    </item>
    <item>
      <title>日本語訳: Trash Your Servers and Burn Your Code: Immutable Infrastructure and Disposable Components</title>
      <link>/contribution/2014/1/21/ja-trash-your-servers-and-burn-your-code-immutable-infrastructure-and-disposable-components</link>
      <content:encoded><![CDATA[<p><a href="https://github.com/azukiwasher/">@azukiwasher</a> さんからチャド・ファウラ氏のブログ日本語訳を頂きました。</p>

<p>元の記事はこちらです。
<a href="http://chadfowler.com/blog/2013/06/23/immutable-deployments/" title="Trash Your Servers and Burn Your Code: Immutable Infrastructure and Disposable Components - Chad Fowler">Trash Your Servers and Burn Your Code: Immutable Infrastructure and Disposable Components - Chad Fowler</a></p>

<hr />
<h2 id="trashyourserversandburnyourcodeimmutableinfrastructureanddisposablecomponents">Trash Your Servers and Burn Your Code: Immutable Infrastructure and Disposable Components</h2>

<h3 id="">サーバーを捨て、コードを燃やせ：イミュータブル・インフラストラクチャとディスポーザブル・コンポーネント</h3>

<p>2013.06.23</p>

<blockquote>
  <p>As a developer and sometimes system administrator, one of the scariest things I ever encounter is a server that’s been running for ages which has seen multiple upgrades of system and application software.</p>
</blockquote>

<p>デベロッパー、そして時に、システム管理者として知り得る最大の恐怖の対象は、システムとアプリケーション・ソフトウェアのアップグレードを何度も繰り返しながら、長年走り続けているサーバーだ。</p>

<blockquote>
  <p>Why? Because an old system inevitably grows warts. They start as one-time hacks during outages. A quick edit to a config file saves the day. “We’ll put it back into Chef later,” we say, as we finally head off to sleep after a marathon fire fighting session.</p>
</blockquote>

<p>なぜ、恐怖の対象かって？古くからのシステムは必ずといってもいいくらい全身がイボイボになってるからだ。そいつらは停電中の急場しのぎで生まれてきた。設定ファイルをちょっと変更すればもう安泰だ。「あとで Chef に突っ込んどくよ」と口では言っても、長時間の熱いセッション（a marathon fire fighting session）に疲れて眠ってしまえば、もうそんなこと憶えてるわけない。</p>

<blockquote>
  <p>Cron jobs spring up in unexpected places, running obscure but critical functions that only one person knows about. Application code is deployed outside of the normal straight-from-source-control process.</p>
</blockquote>

<p>cron ジョブが思いもかけないところで実行されていたりする。それを知ってるのはたった一人で、人知れず実行されてるんだけど、結構クリティカルな機能だったりする。アプリケーション・コードがデプロイされるんだが、それは通常のソース管理プロセスからじゃなかったりする。</p>

<blockquote>
  <p>The system becomes finicky. It only accepts deploys in a certain manual way. The init scripts no longer work unless you do something special and unexpected.</p>
</blockquote>

<p>システムはだんだん気難しいくなっていく。手作業でのデプロイしか受け付けないなんてざらだ。初期化スクリプトは、何かしらスペシャルで予想外なことでもしなけりゃ動いてくれない。</p>

<blockquote>
  <p>And, of course the operating system has been patched again and again (in the best case) in line with the standard operating procedures, and the inevitable entropy sets in. Or, worse, it has never been patched and now you’re too afraid of what would happen if you try.</p>
</blockquote>

<p>あとは、オペレーティング・システムは、もちろん繰り返しパッチが（ベストなケースであれば）スタンダードな手続きで当てられているんだが、そこにはエントロピーが確実に忍び寄ってくるものだ。もっとひどいのは、パッチなんて一度も当てられてなくて、パッチを当てるなんて、何が起こるか恐ろし過ぎていまさらとても当てられないような状態だ。</p>

<blockquote>
  <p>The system becomes a house of cards. You fear any change and you fear replacing it since you don’t know everything about how it works.</p>
</blockquote>

<p>システムはだんだんとカードで組み上げた家に似てくる。どんな変更もリプレイスも恐ろしくなる。システムがどうやって動いているのか、そのすべてが分からないからだ。</p>

<blockquote>
  <p>We’ve tried lots of ways to avoid this problem over the years from team policy to automation. We’re trying a new one now at work : Immutable Deployments.</p>
</blockquote>

<p>この問題を回避するために、チームポリシーの整備から自動化にいたるまで長年いろいろ試してきた。そしていま新しい方法を試しているところだ。それが「イミュータブル・デプロイメント」だ。</p>

<blockquote>
  <p>Many of us in the software industry are starting to take notice of the benefits of immutability in software architecture. We’ve seen an increased interest over the past few years in functional programming techniques with rising popularity of languages such as Erlang, Scala, Haskell, and Clojure. Functional languages offer immutable data structures and single assignment variables. The claim (which many of us believe based on informal empirical evidence) is that immutability leads to programs that are easier to reason about and harder to screw up.</p>
</blockquote>

<p>ソフトウェア産業にいる多く人たちが、ソフトウェア・アーキテクチャにおけるイミュータビリティの恩恵に気づき始めているようだ。Erlang、Scala、Haskell、Clojure といった言語の人気もあり、ここ数年で関数型プログラミング・テクニックへの関心が高まっている。関数型言語はイミュータブルなデータ構造と静的単一代入を提供する。（これは非公式なあくまで経験則に基づいての評価だが）イミュータビリティ（不変性）によってプログラムは説得力のある、改悪しにくいものになる。</p>

<blockquote>
  <p>So why not take this approach (where possible) with infrastructure? If you absolutely know a system has been created via automation and never changed since the moment of creation, most of the problems I describe above disappear. Need to upgrade? No problem. Build a new, upgraded system and throw the old one away. New app revision? Same thing. Build a server (or image) with a new revision and throw away the old ones.</p>
</blockquote>

<p>ならば、このアプローチをインフラストラクチャ（の可能な場所）に適用しない手はないだろう。自動化プロセスで作成したシステムを完全に把握していて作成時点から変更がまったくないなら、上に述べた問題の大半は解決できるはずだ。アップグレード？問題ない。新しいシステムを作って、アップグレードしたら、古いのは捨てる。アプリのリビジョン？同じことだ。新しいサーバ（あるいはイメージ）をビルドするときに、そのリビジョンを含めればいい。そして、古いのは捨てる。</p>

<blockquote>
  <p>At 6Wunderkinder , we have been moving in this direction over the past 4 months. It’s giving us the confidence we need to rapidly iterate on our backend infrastructure as we continue to make things faster, more scalable and dependable for our customers and flexible to move our applications forward more freely.</p>
</blockquote>

<p>6Wunderkinder では、4ヶ月前からこのやり方に変えている。カスタマにとってサービスをさらに早く、さらにスケールして、さらに信頼できるものすること、そしてアプリケーションをもっと自由に前進させていけるよう柔軟にすること、そのためにはインフラ上で迅速にイテレーションする必要があるが、このやり方でわれわれはそれを行う自信を得ている。</p>

<blockquote>
  <p>Maybe more remarkable, though, is that like a new programming paradigm, thinking of infrastructure this way changes how I view our systems pretty fundamentally. New patterns and anti-patterns emerge. It is changing how I think not just about deployments but about application code (and even team structure).</p>
</blockquote>

<p>おそらくもっと注目すべきことは、インフラストラクチャをこのように考えることがシステムの見方を根底から変えてしまうことだ。これは新たなプログラミング・パラダイムに遭遇したときの感覚に似ている。新しいパターンとアンチ・パターンが出現する。デプロイメントに限らず、アプリケーション・コード（さらにはチーム構成）についても、わたしの考え方は変化し続けている。</p>

<blockquote>
  <p>This idea is a work in progress for me. We’re obviously not the first ones to think of it, so there is a lot to learn. It also implies some kind of “cloud” infrastructure, though I think modern software architecture generally does.</p>
</blockquote>

<p>わたしのなかでイミュータブル・インフラというアイデアはまだ未完成だ。もちろん、われわれが始めて着想したアイデアではなく、これから学ぶことは多いはずだ。個人的には、モダンなソフトウェア・アーキテクチャが普通にやっていることではあるが、それはまたある種の「クラウド」なインフラも意味しているはずだ。</p>

<blockquote>
  <p>Expect to hear more about the tactical details of this from me here and at various conferences this year .</p>
</blockquote>

<p>戦術的な詳細についてさらに知りたい方はこのブログでわたしに直接聞くか、<a href="http://railsisrael2013.events.co.il/presentations/852-disposable-components">今年度のカンファレンス</a>をご覧ください。</p>

<blockquote>
  <p>Posted by Chad Fowler 2013.06.23</p>
</blockquote>

<p>2013年6月23日、チャド・ファウラ</p>]]></content:encoded>
      <excerpt:encoded />
      <wp:post_name>2014/1/21/ja-trash-your-servers-and-burn-your-code-immutable-infrastructure-and-disposable-components</wp:post_name>
      <wp:post_type>post</wp:post_type>
      <wp:post_id>3</wp:post_id>
      <wp:status>publish</wp:status>
      <pubDate>Tue, 21 Jan 2014 06:41:18 +0000</pubDate>
      <wp:post_date>2014-01-21 06:41:18</wp:post_date>
      <wp:post_date_gmt>2014-01-21 06:41:18</wp:post_date_gmt>
      <category domain="post_tag" nicename="immutable-infrastructure"><![CDATA[Immutable Infrastructure]]></category>
      <category domain="post_tag" nicename="disposable-components"><![CDATA[Disposable Components]]></category>
      <category domain="post_tag" nicename="translate"><![CDATA[translate]]></category>
      <dc:creator>sawanoboriyu@higanworks.com</dc:creator>
      <wp:comment_status>open</wp:comment_status>
    </item>
    <item>
      <link>/about/</link>
      <title>About</title>
      <pubDate>Fri, 31 Jan 2014 10:23:48 +0000</pubDate>
      <content:encoded><![CDATA[<p>Sawanobolyのサイト</p>]]></content:encoded>
      <wp:post_name>about</wp:post_name>
      <wp:post_type>page</wp:post_type>
      <wp:post_id>4</wp:post_id>
      <wp:status>publish</wp:status>
    </item>
    <item>
      <link>/new-page/</link>
      <title>New Page</title>
      <pubDate>Fri, 31 Jan 2014 10:44:17 +0000</pubDate>
      <content:encoded />
      <wp:post_name>new-page</wp:post_name>
      <wp:post_type>page</wp:post_type>
      <wp:post_id>5</wp:post_id>
      <wp:status>publish</wp:status>
    </item>
  </channel>
</rss>

